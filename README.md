# Genome-Annotation
A Step-By-Step Guide To Conducting Annotation For Bacterial Genomes

This methodology facilitates a comprehensive comparison of genome annotations generated by a variety of tools, including Bakta, Prokka (both from HintonLab and recent versions), as well as NCBI (vBen and vCom) versions. While currently optimised for these specific tools, this approach remains flexible, accommodating other annotation tools provided that the corresponding GFF files are available.

This method is structured as a step-by-step approach, employing multiple smaller codes instead of a single large one, allowing you to make customisations and screen for errors easily. This would create files (intermediate) at the end of each step. The codes and files are organised hierarchically with clear labelling, simplifying navigation and scanning. The overall runtime for the entire pipeline is <30 minutes for one genome (barring any errors arising from file formats). 

A helpful guideline for running this pipeline is to refrain from including spaces in file names or headers within Excel files. While the codes may still run with spaces present, it's advisable to eliminate spaces to minimise the risk of errors.

Step 1- Converting the GFF file into Excel format (1_GFF-to-Excel.py)
In this step, you need to input the GFF file. The code will return an Excel file containing the "Sequence_Name", "Sequence_ID", "Type", "Start", "End", "Length", "Direction", "Gene", and "Product". 
"Sequence_Name" will be the name of your GFF file. Keep it one word for easy analysis.
The name of the output Excel file will be the same as the name of the GFF file. 
Execute this step for each GFF file individually. Simply adjust the input path accordingly.

Step 2- Merge the Excel files generated from various tools (2_Merge-Excel.py)
In this step, consolidate all the Excel files generated from various tools into a single folder. Input the folder path in the code. Since the format of the generated Excel files is consistent, the code will seamlessly merge the data from all files into one single merged file sorted by 'Sequence_Name', 'Sequence_ID', 'Start'.

After this code, check if the Sequence_ID is uniform in the Excel file manually, if not edit in crude Excel files generated in Step 1 and run Step 2 again.

Step 3- Retain data of essential Types (3_Remove-Unwanted-Types.py)
In this step, we consider the annotations of the Type- "CDS", "CRISPR", "ncRNA", "oriC", "oriT", "oriV", "regulatory_region", "rRNA", "tmRNA", "tRNA". 
This step is crucial because certain data types are redundant. For example, the "Direct repeat" type is inherent to the CRISPR array. However, if there are any additional data types you wish to preserve, simply include them in Line 13 of the code.

Step 4- Cleaning gene names (4_Remove-Genes_.py)
In this step, we perform gene name cleaning to ensure consistency across annotations. For example, one tool may annotate a gene as "talB" while another may label it as "talB_1." Such discrepancies often stem from tool-specific conventions or different versions of gene databases. To clean these annotations, the code removes any appended "_number" identifiers.
Additionally, the code standardises all four-letter gene names to the "xyzA" format. This ensures uniformity in gene naming conventions throughout the analysis process.

Step 5- First level of grouping the annotations (5_Grouping-v1.py)
As we have data from various tools, we start by grouping the data. The first criterion for grouping is when the 'Sequence_ID', 'Type', 'Start', 'End', 'Length', and 'Direction' of one row are the exact same as that of other row/s. We retain only one representative row and concatenate the corresponding 'Sequence_Name', 'Gene', and 'Product' values using a delimiter "\". This concatenation follows a standardised format.

For instance- 
If the 'Sequence_Name', 'Gene' and 'Product' are as follows-
Bakta \ Prokka \ vBen \ vCom		W \ X \ Y \ Z 		A \ B \ C \ D

In this instance-
Bakta annotation yields gene W and product A
Prokka annotation yields gene X and product B
vBen annotation yields gene Y and product C
vCom annotation yields gene Z and product D

Output file is sorted by 'Sequence_ID', 'Start.

Step 6- Second level of grouping the annotations (6_Grouping-v2.py)
In this step, we implement a secondary criterion for grouping to address discrepancies in gene start and end positions identified across different tools. Occasionally, we observe that one tool has the gene of a little bigger size than the other tool. 

Here, we examine if the Start OR the End position of one row aligns with that of other rows, provided they share the same 'Sequence_Name' and 'Type'. In such instances, we prioritise selecting the start and end positions that are most chosen by the majority of tools. If an equal number of tools select different start or end positions, the precedence is alphabetically, so first is from Bakta, second Prokka, third vBen and fourth vCom. 

Rest assured; we do not disregard the less preferred row in this process. Instead, we merge the 'Sequence_Name', 'Gene', and 'Product' of these rows using "\" as a delimiter and we include a "#" if the start positions are identical and "##" if the end positions are identical.

Few instances- 
vCom \ ## Bakta \ Prokka \ vBen
This tells you that Bakta, Prokka and vBen had the same start and end and we prefer this Start and End. The end (because ##) is the same as that of vCom.

vBen \ vCom \ ## Bakta \ Prokka
This tells you all tools have the same end.  Bakta and Prokka have the same start, while vBen and vCom have the same start and end. We would choose the start and end of Bakta because that is our preference.
 
vCom \ ## Bakta \ Prokka \ ## vBen
This tells you all tools have the same end. Bakta and Prokka have the same start, while vBen and vCom have different starts. So that is why we have two instances of ##.  We would choose the start and end of Bakta because that is our preference.

Step 7- Third level of grouping the annotations (6_Grouping-v3.py)
In this step, we implement a third criterion for grouping to address very few instances, in which you see one gene inside the other gene. Here, we examine if the Start and the End position of one row are in between that of other row/s, provided they share the same 'Sequence_Name' and 'Type'. 
As these need to be screened manually, to facilitate manual screening, a new column “Status” has been introduced, and the label "overlap" has been assigned to both of these rows. By filtering the Excel sheet, you can promptly assess these instances and make informed decisions through manual checks. It's worth noting that such occurrences are infrequent, so it should be less painful.

Step 8- Choosing the best genes (8_Choosing-Best-Genes.py)
In this step, the gene name, which is picked up the most times, is the best annotation for that tool. 

For instance-
nan \ thrB \ thrB \ thrB- Best gene is thrB
nan \ fkpB \ fkpB \ slpA-Best gene is fkpB

Step 9- Fixing hypothetical protein (9_Choosing-Hypothetical-Protein.py)
In this step, if the Type is CDS and all the tools give the gene name as “nan” or empty. Then we choose the best gene as the “HP” indicating that this is a hypothetical protein. 

Step 10- Choosing the other gene (10_Choose-Single-Gene.py)
In this step, we choose the gene name which is picked only once. So here the preference order of choosing the best gene name is – 1. Bakta, 2. Prokka, 3. vBen and 4. vCom. You can anytime change the order by editing the code in lines 15, 20, 25 and 30. The “Screen(Maybe)” is added in the Status column cell. If you wish to manually check these by filtering the Excel sheet, you can promptly assess these instances and make informed decisions. 

Step 11- Adding gene putative synonyms (11_Gene-Synonyms.py)
In this step, if we encounter any gene names other than the best gene name, we include them in the synonym column. It's important to note that while these additional gene names may often serve as synonyms, it's advisable not to rely on them blindly without further verification. Hence, I call them “putative” synonyms.
 
PERFORM ALL THE MANUAL CURATION AND THEN CONTINUE WITH THE NEXT STEPS. 

Step 12- Adding ID numbers (12_New-ID-Number.py)
This step is optional and should be undertaken solely if new ID numbering for the genome is required. The naming convention follows this order:
SequenceName_Type_5-Digit-Number
The 5-digit number increments sequentially based on the genome location, starting from 00001. Numbering restarts for each new Sequence_Name or Type, or both, ensuring systematic organisation.

Step 13- Make a GFF file for the Excel sheet (13_Excel-to-GFF.py)
The Excel file can be used to now make the final GFF file. 
The methodology used here is SKKPipe. You can change the name in Line 10 of the code. 
The ID is the new IDs generated from Step 12.
The gene_biotype is the same as Type.
The Name is of the best gene (The Name is still blank for HP or regulatory region/RNAs).
The Note is the product (Preference order- Bakta, Prokka, vBen and vCom and avoid hypothetical proteins).
The Dbxref is missing. 
